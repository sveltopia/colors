/**
 * Framework-specific Export Formats
 *
 * Exports palettes in formats that drop directly into popular frameworks:
 * - Tailwind CSS (50-950 scale mapping)
 * - Radix UI Colors (drop-in replacement)
 * - Panda CSS (preset with semantic tokens)
 */

import type { Palette, Scale } from '../types.js';
import { ensureAccessibility } from './validate.js';
import {
	getAlphaColorSrgb,
	getAlphaColorP3,
	formatAlphaHex,
	formatAlphaP3,
	type BrandColorInfo
} from './export.js';

// =============================================================================
// Radix â†’ Tailwind Scale Mapping
// =============================================================================

/**
 * Maps Radix 1-12 steps to Tailwind 50-950 scale.
 *
 * | Radix | Purpose              | Tailwind |
 * |-------|----------------------|----------|
 * | 1     | App background       | 50       |
 * | 2     | Subtle background    | 100      |
 * | 3     | UI element bg        | 200      |
 * | 4     | Hovered UI element   | 300      |
 * | 5     | Active/selected      | 400      |
 * | 6     | Subtle borders       | 500      |
 * | 7     | UI element border    | 600      |
 * | 8     | Hovered borders      | 700      |
 * | 9     | Solid backgrounds    | 800      |
 * | 10    | Hovered solid        | 850      |
 * | 11    | Low-contrast text    | 900      |
 * | 12    | High-contrast text   | 950      |
 */
const RADIX_TO_TAILWIND: Record<number, string> = {
	1: '50',
	2: '100',
	3: '200',
	4: '300',
	5: '400',
	6: '500',
	7: '600',
	8: '700',
	9: '800',
	10: '850',
	11: '900',
	12: '950'
};

// =============================================================================
// Tailwind Export
// =============================================================================

export interface TailwindExportOptions {
	/** Scale numbering system (default: '50-950' for drop-in compatibility) */
	scale?: '50-950' | '1-12';
	/** Dark mode strategy (default: 'class') */
	darkMode?: 'class' | 'media';
	/** Include alpha variants (default: false - adds significant size) */
	includeAlpha?: boolean;
}

/**
 * Export palette as a Tailwind CSS preset file.
 *
 * The generated file can be used as a preset:
 * ```js
 * // tailwind.config.js
 * import sveltopiaColors from './colors/tailwind.config.js'
 * export default {
 *   presets: [sveltopiaColors],
 * }
 * ```
 */
export function exportTailwind(palette: Palette, options: TailwindExportOptions = {}): string {
	const safePalette = ensureAccessibility(palette);
	const { scale = '50-950', darkMode = 'class' } = options;

	const useRadixScale = scale === '1-12';
	const mapping = useRadixScale ? null : RADIX_TO_TAILWIND;

	// Build color object for a scale
	const buildScale = (scaleData: Scale): Record<string, string> => {
		const result: Record<string, string> = {};
		for (let step = 1; step <= 12; step++) {
			const key = mapping ? mapping[step] : String(step);
			result[key] = scaleData[step as keyof Scale];
		}
		return result;
	};

	// Build all light mode colors
	const lightColors: Record<string, Record<string, string>> = {};
	for (const [name, scale] of Object.entries(safePalette.light)) {
		lightColors[name] = buildScale(scale);
	}

	// Build all dark mode colors
	const darkColors: Record<string, Record<string, string>> = {};
	for (const [name, scale] of Object.entries(safePalette.dark)) {
		darkColors[name] = buildScale(scale);
	}

	// Generate the Tailwind config file content
	const brandColors = safePalette._meta.tuningProfile.anchors
		? Object.keys(safePalette._meta.tuningProfile.anchors)
		: [];

	// Determine which hues are brand-anchored vs baseline
	const anchoredHues = new Set(
		Object.values(safePalette._meta.tuningProfile.anchors || {}).map((a) => a.slot)
	);
	const allHues = Object.keys(safePalette.light);
	const baselineHues = allHues.filter((h) => !anchoredHues.has(h));
	const customHues = allHues.filter((h) => h.startsWith('custom-'));

	const output = `// Generated by @sveltopia/colors
// Brand colors: ${brandColors.join(', ') || 'none'}
// Generated at: ${new Date().toISOString()}
//
// Hue coverage (${allHues.length} scales):
//   Brand-anchored: ${[...anchoredHues].join(', ') || 'none'}
//   Baseline (Radix-compatible): ${baselineHues.filter((h) => !h.startsWith('custom-')).join(', ')}
${customHues.length > 0 ? `//   Custom rows: ${customHues.join(', ')}\n` : ''}
/** @type {import('tailwindcss').Config} */
export default {
  darkMode: '${darkMode}',
  theme: {
    extend: {
      colors: ${JSON.stringify(lightColors, null, 8).replace(/^/gm, '      ').trim()},
    },
  },
  plugins: [
    // Dark mode color overrides
    function({ addBase }) {
      addBase({
        '.dark': {
          ${Object.entries(darkColors)
						.map(([name, scale]) => {
							return Object.entries(scale)
								.map(([step, hex]) => `'--color-${name}-${step}': '${hex}'`)
								.join(',\n          ');
						})
						.join(',\n          ')}
        }
      });
    },
  ],
};
`;

	return output;
}

/**
 * Export palette as Tailwind CSS with CSS custom properties approach.
 * This is an alternative that uses CSS variables for better dark mode support.
 */
export function exportTailwindWithCSSVars(
	palette: Palette,
	options: TailwindExportOptions = {}
): string {
	const safePalette = ensureAccessibility(palette);
	const { scale = '50-950', darkMode = 'class' } = options;

	const useRadixScale = scale === '1-12';
	const mapping = useRadixScale ? null : RADIX_TO_TAILWIND;

	// Build CSS variable references for Tailwind
	const buildColorRefs = (scaleNames: string[]): Record<string, Record<string, string>> => {
		const result: Record<string, Record<string, string>> = {};
		for (const name of scaleNames) {
			result[name] = {};
			for (let step = 1; step <= 12; step++) {
				const key = mapping ? mapping[step] : String(step);
				result[name][key] = `rgb(var(--color-${name}-${key}) / <alpha-value>)`;
			}
		}
		return result;
	};

	// Build CSS variable values
	const buildCSSVars = (
		scales: Record<string, Scale>,
		prefix: string = ''
	): Record<string, string> => {
		const vars: Record<string, string> = {};
		for (const [name, scale] of Object.entries(scales)) {
			for (let step = 1; step <= 12; step++) {
				const key = mapping ? mapping[step] : String(step);
				const hex = scale[step as keyof Scale];
				// Convert hex to RGB values for Tailwind's alpha modifier support
				const r = parseInt(hex.slice(1, 3), 16);
				const g = parseInt(hex.slice(3, 5), 16);
				const b = parseInt(hex.slice(5, 7), 16);
				vars[`--color-${name}-${key}`] = `${r} ${g} ${b}`;
			}
		}
		return vars;
	};

	const scaleNames = Object.keys(safePalette.light);
	const colorRefs = buildColorRefs(scaleNames);
	const lightVars = buildCSSVars(safePalette.light);
	const darkVars = buildCSSVars(safePalette.dark);

	const brandColors = safePalette._meta.tuningProfile.anchors
		? Object.keys(safePalette._meta.tuningProfile.anchors)
		: [];

	const output = `// Generated by @sveltopia/colors
// Brand colors: ${brandColors.join(', ') || 'none'}
// Generated at: ${new Date().toISOString()}
//
// This config uses CSS custom properties for better dark mode support.
// Include the generated CSS file in your project for the variables.

/** @type {import('tailwindcss').Config} */
export default {
  darkMode: '${darkMode}',
  theme: {
    extend: {
      colors: ${JSON.stringify(colorRefs, null, 8).replace(/^/gm, '      ').trim()},
    },
  },
};

// CSS to include in your stylesheets:
/*
:root {
${Object.entries(lightVars)
		.map(([key, value]) => `  ${key}: ${value};`)
		.join('\n')}
}

.dark {
${Object.entries(darkVars)
		.map(([key, value]) => `  ${key}: ${value};`)
		.join('\n')}
}
*/
`;

	return output;
}

// =============================================================================
// Radix Export
// =============================================================================

export interface RadixExportOptions {
	/** Include alpha variants (default: true) */
	includeAlpha?: boolean;
	/** Include P3 wide gamut variants (default: true) */
	includeP3?: boolean;
	/** Export format: 'esm' for ES modules, 'cjs' for CommonJS (default: 'esm') */
	format?: 'esm' | 'cjs';
}

/**
 * Export palette in Radix UI Colors format.
 *
 * Generates files that exactly match @radix-ui/colors structure:
 * - Named exports for each scale (red, redA, redP3, redP3A, redDark, etc.)
 * - Same key naming convention (red1, red2, ... red12)
 * - Tree-shakeable named exports
 */
export function exportRadix(palette: Palette, options: RadixExportOptions = {}): string {
	const safePalette = ensureAccessibility(palette);
	const { includeAlpha = true, includeP3 = true, format = 'esm' } = options;

	const exports: string[] = [];
	const allExportNames: string[] = [];

	// Helper to build a scale object string
	const buildScaleObject = (
		name: string,
		scale: Scale,
		suffix: string = ''
	): string => {
		const entries = [];
		for (let step = 1; step <= 12; step++) {
			entries.push(`  ${name}${suffix}${step}: '${scale[step as keyof Scale]}'`);
		}
		return `{\n${entries.join(',\n')}\n}`;
	};

	// Helper to build alpha scale
	const buildAlphaScaleObject = (
		name: string,
		scale: Scale,
		mode: 'light' | 'dark',
		suffix: string = 'A'
	): string => {
		const backgroundHex = mode === 'light' ? '#ffffff' : '#000000';
		const entries = [];
		for (let step = 1; step <= 12; step++) {
			const hex = scale[step as keyof Scale];
			const [r, g, b, a] = getAlphaColorSrgb(hex, backgroundHex);
			entries.push(`  ${name}${suffix}${step}: '${formatAlphaHex(r, g, b, a)}'`);
		}
		return `{\n${entries.join(',\n')}\n}`;
	};

	// Helper to build P3 scale
	const buildP3ScaleObject = (
		name: string,
		scale: Scale,
		suffix: string = 'P3'
	): string => {
		const entries = [];
		for (let step = 1; step <= 12; step++) {
			const hex = scale[step as keyof Scale];
			// Convert to P3 color string
			const p3Str = hexToP3(hex);
			entries.push(`  ${name}${suffix}${step}: '${p3Str}'`);
		}
		return `{\n${entries.join(',\n')}\n}`;
	};

	// Helper to build P3 alpha scale
	const buildP3AlphaScaleObject = (
		name: string,
		scale: Scale,
		mode: 'light' | 'dark',
		suffix: string = 'P3A'
	): string => {
		const backgroundHex = mode === 'light' ? '#ffffff' : '#000000';
		const entries = [];
		for (let step = 1; step <= 12; step++) {
			const hex = scale[step as keyof Scale];
			const [r, g, b, a] = getAlphaColorP3(hex, backgroundHex);
			entries.push(`  ${name}${suffix}${step}: '${formatAlphaP3(r, g, b, a)}'`);
		}
		return `{\n${entries.join(',\n')}\n}`;
	};

	// Process each scale
	for (const [name, lightScale] of Object.entries(safePalette.light)) {
		const darkScale = safePalette.dark[name];

		// Light mode - base
		const exportName = name;
		allExportNames.push(exportName);
		if (format === 'esm') {
			exports.push(`export const ${exportName} = ${buildScaleObject(name, lightScale)};`);
		} else {
			exports.push(`const ${exportName} = ${buildScaleObject(name, lightScale)};`);
		}

		// Light mode - alpha
		if (includeAlpha) {
			const alphaName = `${name}A`;
			allExportNames.push(alphaName);
			if (format === 'esm') {
				exports.push(
					`export const ${alphaName} = ${buildAlphaScaleObject(name, lightScale, 'light')};`
				);
			} else {
				exports.push(
					`const ${alphaName} = ${buildAlphaScaleObject(name, lightScale, 'light')};`
				);
			}
		}

		// Light mode - P3
		if (includeP3) {
			const p3Name = `${name}P3`;
			allExportNames.push(p3Name);
			if (format === 'esm') {
				exports.push(`export const ${p3Name} = ${buildP3ScaleObject(name, lightScale)};`);
			} else {
				exports.push(`const ${p3Name} = ${buildP3ScaleObject(name, lightScale)};`);
			}
		}

		// Light mode - P3 Alpha
		if (includeAlpha && includeP3) {
			const p3aName = `${name}P3A`;
			allExportNames.push(p3aName);
			if (format === 'esm') {
				exports.push(
					`export const ${p3aName} = ${buildP3AlphaScaleObject(name, lightScale, 'light')};`
				);
			} else {
				exports.push(
					`const ${p3aName} = ${buildP3AlphaScaleObject(name, lightScale, 'light')};`
				);
			}
		}

		// Dark mode - base
		const darkName = `${name}Dark`;
		allExportNames.push(darkName);
		if (format === 'esm') {
			exports.push(`export const ${darkName} = ${buildScaleObject(name, darkScale)};`);
		} else {
			exports.push(`const ${darkName} = ${buildScaleObject(name, darkScale)};`);
		}

		// Dark mode - alpha
		if (includeAlpha) {
			const darkAlphaName = `${name}DarkA`;
			allExportNames.push(darkAlphaName);
			if (format === 'esm') {
				exports.push(
					`export const ${darkAlphaName} = ${buildAlphaScaleObject(name, darkScale, 'dark')};`
				);
			} else {
				exports.push(
					`const ${darkAlphaName} = ${buildAlphaScaleObject(name, darkScale, 'dark')};`
				);
			}
		}

		// Dark mode - P3
		if (includeP3) {
			const darkP3Name = `${name}DarkP3`;
			allExportNames.push(darkP3Name);
			if (format === 'esm') {
				exports.push(`export const ${darkP3Name} = ${buildP3ScaleObject(name, darkScale)};`);
			} else {
				exports.push(`const ${darkP3Name} = ${buildP3ScaleObject(name, darkScale)};`);
			}
		}

		// Dark mode - P3 Alpha
		if (includeAlpha && includeP3) {
			const darkP3aName = `${name}DarkP3A`;
			allExportNames.push(darkP3aName);
			if (format === 'esm') {
				exports.push(
					`export const ${darkP3aName} = ${buildP3AlphaScaleObject(name, darkScale, 'dark')};`
				);
			} else {
				exports.push(
					`const ${darkP3aName} = ${buildP3AlphaScaleObject(name, darkScale, 'dark')};`
				);
			}
		}

		exports.push(''); // Blank line between scales
	}

	// Build header comment
	const brandColors = safePalette._meta.tuningProfile.anchors
		? Object.keys(safePalette._meta.tuningProfile.anchors)
		: [];

	// Determine which hues are brand-anchored vs baseline
	const anchoredHues = new Set(
		Object.values(safePalette._meta.tuningProfile.anchors || {}).map((a) => a.slot)
	);
	const allHues = Object.keys(safePalette.light);
	const baselineHues = allHues.filter((h) => !anchoredHues.has(h) && !h.startsWith('custom-'));
	const customHues = allHues.filter((h) => h.startsWith('custom-'));

	let header = `/**
 * Generated by @sveltopia/colors
 * Brand colors: ${brandColors.join(', ') || 'none'}
 * Generated at: ${new Date().toISOString()}
 *
 * Drop-in replacement for @radix-ui/colors
 * Usage:
 *   import { red, redA, redDark, redDarkA } from './colors.js';
 *
 * Hue coverage (${allHues.length} scales):
 *   Brand-anchored: ${[...anchoredHues].join(', ') || 'none'}
 *   Baseline (Radix drop-in): ${baselineHues.join(', ')}
${customHues.length > 0 ? ` *   Custom rows: ${customHues.join(', ')}\n` : ''} */

`;

	// Add CJS exports if needed
	if (format === 'cjs') {
		const cjsExports = `\nmodule.exports = {\n  ${allExportNames.join(',\n  ')}\n};\n`;
		return header + exports.join('\n') + cjsExports;
	}

	return header + exports.join('\n');
}

// =============================================================================
// Panda CSS Export
// =============================================================================

export interface PandaExportOptions {
	/** Include semantic tokens for accent/brand (default: true) */
	includeSemantic?: boolean;
}

/**
 * Export palette as a Panda CSS preset.
 *
 * Generates a preset file that can be imported into panda.config.ts:
 * ```ts
 * import { sveltopiaColors } from './colors/panda.preset';
 * export default defineConfig({
 *   presets: [sveltopiaColors],
 * });
 * ```
 *
 * Dark mode is automatic - just use `orange.1` and it switches based on
 * `data-theme` attribute or `.dark` class on a parent element.
 */
export function exportPanda(
	palette: Palette,
	brandColorInfo: BrandColorInfo[],
	options: PandaExportOptions = {}
): string {
	const safePalette = ensureAccessibility(palette);
	const { includeSemantic = true } = options;

	// Build raw token structure for all scales (both light and dark)
	const buildRawTokens = (
		lightScales: Record<string, Scale>,
		darkScales: Record<string, Scale>
	): Record<string, Record<string, { value: string }>> => {
		const tokens: Record<string, Record<string, { value: string }>> = {};

		// Add light mode tokens (e.g., orangeLight)
		for (const [name, scale] of Object.entries(lightScales)) {
			tokens[`${name}Light`] = {};
			for (let step = 1; step <= 12; step++) {
				tokens[`${name}Light`][step] = { value: scale[step as keyof Scale] };
			}
		}

		// Add dark mode tokens (e.g., orangeDark)
		for (const [name, scale] of Object.entries(darkScales)) {
			tokens[`${name}Dark`] = {};
			for (let step = 1; step <= 12; step++) {
				tokens[`${name}Dark`][step] = { value: scale[step as keyof Scale] };
			}
		}

		return tokens;
	};

	// Build semantic tokens that wire light/dark together with conditions
	const buildSemanticColorTokens = (
		scaleNames: string[]
	): Record<string, Record<string | number, { value: { base: string; _dark: string } }>> => {
		const semanticColors: Record<string, Record<string | number, { value: { base: string; _dark: string } }>> = {};

		for (const name of scaleNames) {
			semanticColors[name] = {};
			for (let step = 1; step <= 12; step++) {
				semanticColors[name][step] = {
					value: {
						base: `{colors.${name}Light.${step}}`,
						_dark: `{colors.${name}Dark.${step}}`
					}
				};
			}
		}

		return semanticColors;
	};

	const rawTokens = buildRawTokens(safePalette.light, safePalette.dark);
	const scaleNames = Object.keys(safePalette.light);
	const semanticColorTokens = buildSemanticColorTokens(scaleNames);

	// Build additional semantic tokens for accent/brand if we have brand color info
	let brandSemanticTokens: Record<string, unknown> = {};
	if (includeSemantic && brandColorInfo.length > 0) {
		const primary = brandColorInfo[0];
		const secondary = brandColorInfo[1] || { hue: 'gray', anchorStep: 11 };

		// Build accent scale that references the primary brand hue
		const accentTokens: Record<string | number, { value: { base: string; _dark: string } }> = {};
		for (let step = 1; step <= 12; step++) {
			accentTokens[step] = {
				value: {
					base: `{colors.${primary.hue}Light.${step}}`,
					_dark: `{colors.${primary.hue}Dark.${step}}`
				}
			};
		}
		accentTokens['DEFAULT'] = {
			value: {
				base: `{colors.${primary.hue}Light.${primary.anchorStep}}`,
				_dark: `{colors.${primary.hue}Dark.${primary.anchorStep}}`
			}
		};

		brandSemanticTokens = {
			accent: accentTokens,
			brand: {
				primary: {
					value: {
						base: `{colors.${primary.hue}Light.${primary.anchorStep}}`,
						_dark: `{colors.${primary.hue}Dark.${primary.anchorStep}}`
					}
				},
				secondary: {
					value: {
						base: `{colors.${secondary.hue}Light.${secondary.anchorStep}}`,
						_dark: `{colors.${secondary.hue}Dark.${secondary.anchorStep}}`
					}
				}
			}
		};
	}

	// Merge all semantic color tokens
	const allSemanticColors = {
		...semanticColorTokens,
		...(includeSemantic && brandColorInfo.length > 0 ? brandSemanticTokens : {})
	};

	const brandColors = brandColorInfo.map((b) => b.hex);

	// Determine which hues are brand-anchored vs baseline
	const anchoredHues = new Set(
		Object.values(safePalette._meta.tuningProfile.anchors || {}).map((a) => a.slot)
	);
	const allHues = Object.keys(safePalette.light);
	const baselineHues = allHues.filter((h) => !anchoredHues.has(h) && !h.startsWith('custom-'));
	const customHues = allHues.filter((h) => h.startsWith('custom-'));

	const output = `/**
 * Generated by @sveltopia/colors
 * Brand colors: ${brandColors.join(', ') || 'none'}
 * Generated at: ${new Date().toISOString()}
 *
 * Usage:
 *   import { sveltopiaColors } from './panda.preset';
 *   export default defineConfig({ presets: [sveltopiaColors] });
 *
 * Dark mode is automatic! Just add data-theme="dark" or class="dark" to a parent:
 *   <html data-theme="dark">
 *   <div class={css({ bg: 'orange.3' })}> // Automatically uses dark palette
 *
 * Hue coverage (${allHues.length} scales):
 *   Brand-anchored: ${[...anchoredHues].join(', ') || 'none'}
 *   Baseline (Radix-compatible): ${baselineHues.join(', ')}
${customHues.length > 0 ? ` *   Custom rows: ${customHues.join(', ')}\n` : ''} */

import { definePreset } from '@pandacss/dev';

export const sveltopiaColors = definePreset({
  theme: {
    conditions: {
      light: '[data-theme=light] &, .light &',
      dark: '[data-theme=dark] &, .dark &'
    },
    tokens: {
      colors: ${JSON.stringify(rawTokens, null, 8).replace(/^/gm, '      ').trim()}
    },
    semanticTokens: {
      colors: ${JSON.stringify(allSemanticColors, null, 8).replace(/^/gm, '      ').trim()}
    }
  }
});
`;

	return output;
}

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Convert hex color to P3 color string
 */
function hexToP3(hex: string): string {
	const r = parseInt(hex.slice(1, 3), 16) / 255;
	const g = parseInt(hex.slice(3, 5), 16) / 255;
	const b = parseInt(hex.slice(5, 7), 16) / 255;
	return `color(display-p3 ${r.toFixed(4)} ${g.toFixed(4)} ${b.toFixed(4)})`;
}
